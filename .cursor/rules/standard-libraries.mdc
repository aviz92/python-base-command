---
description: Internal libraries and standardized integrations (apply only when relevant).
globs:
  - "**/*.py"
alwaysApply: true
---

# Scope Control (CRITICAL)
Apply these standards ONLY when:
- The task involves logging, external integrations, or infrastructure concerns
- New functionality requires these capabilities

Do NOT:
- Replace existing libraries or patterns unless explicitly requested
- Introduce internal libraries if the current codebase uses a different approach
- Add integrations (Jira, Vault, GitHub, etc.) unless required by the task
- Modify existing logging or exception strategy without request

Always follow existing project patterns first.

---

# Internal Library Usage Policy

When new functionality requires these capabilities, prefer the internal stack below.

## Logging
If logging is required and the project uses the internal logger:
- Initialize once in the main entry point:
  `build_logger()`
- In modules:
  `from custom_python_logger import get_logger`
  `logger = get_logger(__name__)`

Do NOT use the standard `logging` module for new code when the internal logger is already in use.

---

## Exceptions
For new domain or application exceptions:
- Inherit from:
  `from python_custom_exceptions import BaseCustomException`

Do not refactor existing exceptions unless requested.

---

## REST APIs
When implementing new external API clients:
- Prefer:
  `from pyrest_model_client import RestClient`
- Use Pydantic models for request/response schemas.

Do not replace existing HTTP clients unless explicitly requested.

---

## Secrets
When secret management is required:
- Prefer .env or `python-vault`
- Never hardcode secrets
- Assume configuration is environment-driven

Only introduce Vault if the task explicitly involves secret retrieval.

---

## Issue Tracking / SCM Integrations
Use only when the task explicitly involves these systems:
- Jira → `python-jira-plus`
- GitLab → `python-gitlab-plus`
- GitHub → `python-github-plus`

Do not introduce these libraries unless the task requires integration.

---

## Django REST CRUD
When creating new DRF CRUD endpoints:
- Prefer `EasyCRUDViewSet` from `drf-easy-crud`

Do not refactor existing viewsets unless requested.

---

# Testing Standards
- Use `pytest`
- Shared fixtures in `conftest.py`
- Prefer fixtures over manual setup
- Use plugins only if the project already uses them
